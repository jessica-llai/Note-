organised materials for JS learning from @freecodecamp

# Access Multi-Dimensional Arrays With Indexes
One way to think of a multi-dimensional array, is as an array of arrays. When you use brackets to access your array, the first set of brackets refers to the entries in the outer-most (the first level) array, and each additional pair of brackets refers to the next level of entries inside.
const arr = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
  [[10, 11, 12], 13, 14]
];
arr[3] is [[10, 11, 12], 13, 14], arr[3][0] is [10, 11, 12], and arr[3][0][1] is 11.

#a.push(int/string/list...)
const array1 = [1,3,5]
array1.push(100) 
array1 = [1,3,5,100]

#x.pop()
.pop() is used to pop a value off of the end of an array. We can store this popped off value by assigning it to a variable. In other words, .pop() removes the last element from an array and returns that element.
const x = [1,2,3]
const y = x.pop()
y = 3, x = [1,2]

#a.shift()
function as pop() but with the first item in a

# a.unshift()
functiom as push() but add element in fromt of an array 

# list 
Create a shopping list in the variable myList. The list should be a multi-dimensional array containing several sub-arrays.
The first element in each sub-array should contain a string with the name of the item. The second element should be a number representing the quantity i.e.
const myList = [["Chocolate Bar", 15],["Chocolate Bar", 15],["Chocolate Bar", 15]]

# function - reusable JS
function reusableFunction() {
  console.log("Hi World");
}
reusableFunction() --- result: Hi World

# pass values to function 
function printing(x, y) {
  console.log(x, y);
  console.log(x+y)
}
printing("Jessica","is amazing") --- result: Jessica is amazing
printiting(100,1) --- result: 101

# return 
function timesFive(x) {
  return x*5
}
timesFive(10) --- result: 50 


# local scope and function 
Variables which are declared within a function, as well as the function parameters, have local scope. That means they are only visible within that function.
function myTest() {
  const loc = "foo";
  console.log(loc);
}

myTest(); = foo
console.log(loc); = error, as loc not defined outside 

#Global vs. Local Scope in Functions
It is possible to have both local and global variables with the same name. When you do this, the local variable takes precedence over the global variable.
Variables which are declared without the let or const keywords are automatically created in the global scope. 


const someVar = "Hat";

function myFun() {
  const someVar = "Head";
  return someVar;
}
myFun() = Head

# undefined value from a function 
if did not have a return statement within a function, then if you call it, returned value = undefined 

# asisgnment with a returned value 
can do x = functionA(10)

# boolean values 
not need for qutation mark

# if condition 
function test (x) {
  if (x) {
    return "It was true";
  }
  return "It was false";
}

test(true); = It was true
test(false); = It was false 

# if conditions with equality operator 
function test(x) {
  if (x==1) { 
  return "true"
  }
  return "false"
}
(btw, if use strict euqality operator ===, then even the data type should be the same)
(strict not euqal to: !==, less strict not equal to !=)
# can add multiple conditions 
function comaprison(a,b,c) {
  if (a===b===c) {
  return "true"
  }
  return "false"

}
(btw, can use typeof "3" to know data type)


# operator 
and &&
or ||
if() {
} else if {
} else {
}

# Logical Order in If Else Statements
if satisfy the first condition, then return that one and stop running 


# default statement in switch 
function switch1(x){
  y="";
  
  switch (x) {
  case "a":
    y="aaa";
    break;
  case "b":
    y="bbb";
    break;
...
  default:
    y="what the fuck is this";
    break;
    }
    return y;

}
switch1(a) = aaa

# multiple identical options in switch statements 
function sequentialSizes(val) {
  let answer = "";
  // Only change code below this line
  switch(val){
    case 1:
    case 2:
    case 3: 
      answer="Low";
      break;
    case 4:
    case 5:
    case 6:
      answer="Mid";
      break;
    case 7:
    case 8:
    case 9:
      answer="High";
      break;
  }



  // Only change code above this line
  return answer;
}

sequentialSizes(1); = low; if no break, wont stop and wont print 

#replacing if else chains with switch 
tips: case arlready means ===
case 1 means val===1

# returning boolean values 
1===
function isEqual(x,y) {
if (x===y){
  return true;
  } else {
  return false;
  }
}
2===
function isEqual(x,y){
return(x===y) # can replace with ><!=

}

#returne early pattern in a function 

function myFun() {
  console.log("Hello");
  return "World";
  console.log("byebye")
}
myFun(); = "world", and the byebye will not shown wiothoyt a return 
tips: undefined value is not a string, no need for ""

# object 
access the data in objects through what are called properties.
can put an array in an object 
const shibaInu = {
  "name": "piggy",
  legs: 4,
  tails: 1,
  friends: ["jessica, william"]
  }
  
 # accessing object property 
 can use both . and [] to call property; notice that if the property name had space, must use [] with quatation
 
 cost test = {
 a:1,
 "b":2
 }
const test1=test.a
const test2 = test[b]

# access object prop with variables 
const className={
1: "orange",
2: "apple"
}

const classNumber=1;
const class=className[classnumber]















